"""
Exploit & Session Management Routes
API endpoints for exploit execution and session management — REAL DATA ONLY
All sessions and data are tracked in real-time; no simulated/hardcoded entries.
"""

from flask import Blueprint, jsonify, request
from datetime import datetime
import time

bp = Blueprint('exploits', __name__, url_prefix='/api/exploits')

# Real in-memory session store — starts empty, populated only by actual user actions
active_sessions = {}
compromised_hosts = {}
killchain_state = {
    'phases': [
        {'name': 'RECON', 'status': 'pending'},
        {'name': 'WEAPONIZE', 'status': 'pending'},
        {'name': 'DELIVER', 'status': 'pending'},
        {'name': 'EXPLOIT', 'status': 'pending'},
        {'name': 'INSTALL', 'status': 'pending'},
        {'name': 'C2', 'status': 'pending'},
        {'name': 'EXECUTE', 'status': 'pending'}
    ]
}

@bp.route('/sessions', methods=['GET'])
def get_sessions():
    """Get all active exploit sessions — only real, user-initiated sessions"""
    # Update last_seen timestamps
    now = time.time()
    for sid, session in active_sessions.items():
        elapsed = int(now - session.get('_created', now))
        if elapsed < 60:
            session['last_seen'] = f'{elapsed}s ago'
        elif elapsed < 3600:
            session['last_seen'] = f'{elapsed // 60}m ago'
        else:
            session['last_seen'] = f'{elapsed // 3600}h ago'
    
    return jsonify(list(active_sessions.values()))

@bp.route('/sessions/<session_id>', methods=['GET'])
def get_session(session_id):
    """Get specific session details"""
    session = active_sessions.get(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    return jsonify(session)

@bp.route('/sessions/<session_id>', methods=['DELETE'])
def kill_session(session_id):
    """Kill a specific session"""
    if session_id in active_sessions:
        del active_sessions[session_id]
        return jsonify({'status': 'killed', 'session_id': session_id})
    return jsonify({'error': 'Session not found'}), 404

@bp.route('/sessions/kill-all', methods=['POST'])
def kill_all_sessions():
    """Kill all active sessions"""
    count = len(active_sessions)
    active_sessions.clear()
    compromised_hosts.clear()
    # Reset killchain
    for phase in killchain_state['phases']:
        phase['status'] = 'pending'
    return jsonify({'status': 'all_killed', 'sessions_terminated': count})

@bp.route('/launch', methods=['POST'])
def launch_exploit():
    """Register an exploit launch — tracks real user-initiated actions"""
    data = request.get_json()
    
    target = data.get('target')
    exploit = data.get('exploit')
    payload = data.get('payload', {})
    
    if not target or not exploit:
        return jsonify({'error': 'Missing required parameters: target, exploit'}), 400
    
    session_id = f"MSF_{len(active_sessions) + 1:03d}"
    
    session = {
        'id': session_id,
        'target': target,
        'exploit': exploit,
        'status': 'launched',
        'timestamp': datetime.now().isoformat(),
        'payload': payload,
        'last_seen': '0s ago',
        '_created': time.time()
    }
    
    active_sessions[session_id] = session
    
    # Advance killchain based on action
    _advance_killchain('DELIVER')
    
    return jsonify({
        'session_id': session_id,
        'status': 'launched',
        'message': f'Exploit registered against {target}'
    })

@bp.route('/compromised', methods=['GET'])
def get_compromised_hosts():
    """Get list of compromised hosts — only real, user-registered entries"""
    # Update timestamps
    now = time.time()
    hosts_list = []
    for ip, host in compromised_hosts.items():
        elapsed = int(now - host.get('_created', now))
        host['last_seen'] = f'{elapsed}s ago' if elapsed < 60 else f'{elapsed // 60}m ago'
        hosts_list.append(host)
    
    return jsonify(hosts_list)

@bp.route('/compromised', methods=['POST'])
def register_compromised_host():
    """Register a compromised host (from successful exploit)"""
    data = request.get_json()
    
    ip = data.get('ip')
    if not ip:
        return jsonify({'error': 'Missing IP address'}), 400
    
    host = {
        'ip': ip,
        'hostname': data.get('hostname', 'unknown'),
        'os': data.get('os', 'unknown'),
        'privilege': data.get('privilege', 'user'),
        'shell': data.get('shell', 'unknown'),
        'last_seen': '0s ago',
        'loot': 0,
        '_created': time.time()
    }
    
    compromised_hosts[ip] = host
    _advance_killchain('EXPLOIT')
    
    return jsonify({'status': 'registered', 'host': host})

@bp.route('/killchain', methods=['GET'])
def get_killchain_status():
    """Get current kill chain progress — reflects real user actions"""
    return jsonify(killchain_state)

@bp.route('/killchain/advance', methods=['POST'])
def advance_killchain():
    """Manually advance killchain phase"""
    data = request.get_json()
    phase_name = data.get('phase', '').upper()
    _advance_killchain(phase_name)
    return jsonify(killchain_state)

@bp.route('/killchain/reset', methods=['POST'])
def reset_killchain():
    """Reset killchain to initial state"""
    for phase in killchain_state['phases']:
        phase['status'] = 'pending'
    return jsonify(killchain_state)


def _advance_killchain(phase_name):
    """Mark a killchain phase as complete and set the next as active"""
    found = False
    for i, phase in enumerate(killchain_state['phases']):
        if phase['name'] == phase_name:
            phase['status'] = 'complete'
            # Mark next phase as active
            if i + 1 < len(killchain_state['phases']):
                if killchain_state['phases'][i + 1]['status'] == 'pending':
                    killchain_state['phases'][i + 1]['status'] = 'active'
            found = True
        elif not found and phase['status'] == 'pending':
            # Mark all phases before the target as complete
            phase['status'] = 'complete'
